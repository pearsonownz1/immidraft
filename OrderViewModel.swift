import Foundation
import Combine // For ObservableObject, @Published
import Supabase // For Supabase types if needed directly for Order struct

// Define the Order struct that matches the 'ios_orders' table schema
struct Order: Encodable {
    // 'id' is generated by Supabase, so it's not included at creation time from client.
    // It will be part of the response if needed.
    var user_id: UUID // Assuming you have the user's UUID
    var user_email: String
    var documents: [String]? // Array of Supabase storage paths
    var language_from: String
    var language_to: String
    var service_type: String
    var page_count: Int? // Nullable if not applicable (e.g., for fixed-price services)
    var price_per_page: Double? // Nullable
    var total_amount: Double
    var stripe_payment_intent_id: String
    var order_status: String // e.g., "Pending", "Processing", "Completed"

    // CodingKeys to map Swift struct properties to snake_case database columns
    enum CodingKeys: String, CodingKey {
        case user_id
        case user_email
        case documents
        case language_from
        case language_to
        case service_type
        case page_count
        case price_per_page
        case total_amount
        case stripe_payment_intent_id
        case order_status
    }
}


@MainActor
class OrderViewModel: ObservableObject {
    // MARK: - Published Properties for Order Details
    @Published var userEmail: String = ""
    @Published var userId: UUID? // Store the user's UUID
    @Published var languageFrom: String = "English" { didSet { calculatePrice() } }
    @Published var languageTo: String = "Spanish" { didSet { calculatePrice() } }
    @Published var serviceType: String { didSet { calculatePrice() } }
    @Published var numberOfPagesString: String = "1" { didSet { calculatePrice() } }
    
    @Published var calculatedPrice: Double = 0.0
    @Published var isSavingOrder: Bool = false // For loading state during save
    @Published var successfullySavedOrderId: UUID? // To store the ID of the saved order
    @Published var orderSavingError: String?

    // MARK: - Available Options for Pickers
    @Published var availableLanguages: [String] = ["English", "Spanish", "French", "German", "Chinese", "Japanese", "Arabic", "Portuguese", "Russian", "Italian"]
    @Published var serviceTypes: [String] = ["Certified Translation", "Diploma Evaluation", "Course-by-Course"]

    // MARK: - File Uploader
    @Published var fileUploaderViewModel: FileUploaderViewModel

    // MARK: - Error Handling
    @Published var errorMessage: String? // General errors for the view

    // MARK: - Pricing Constants
    private let pricePerPageCertified: Double = 25.00
    private let priceFixedDiploma: Double = 150.00
    private let priceFixedCourseByCourse: Double = 250.00

    private var cancellables = Set<AnyCancellable>()

    init(userEmail: String = "", userId: UUID? = nil) {
        self.userEmail = userEmail
        self.userId = userId
        self.serviceType = serviceTypes.first ?? "Certified Translation"
        self.fileUploaderViewModel = FileUploaderViewModel()
        
        calculatePrice()
    }

    func calculatePrice() {
        let pages = Int(numberOfPagesString) ?? 0
        
        switch serviceType {
        case "Certified Translation":
            calculatedPrice = Double(pages) * pricePerPageCertified
        case "Diploma Evaluation":
            calculatedPrice = priceFixedDiploma
        case "Course-by-Course":
            calculatedPrice = priceFixedCourseByCourse
        default:
            calculatedPrice = 0.0
        }
        print("Calculated price: \(calculatedPrice) for service: \(serviceType), pages: \(pages)")
    }
    
    func updateUser(email: String?, id: UUID?) {
        self.userEmail = email ?? ""
        self.userId = id
    }

    // MARK: - Order Submission Logic
    func saveOrderToSupabase(paymentIntentId: String, status: String) async {
        guard let currentUserId = self.userId else {
            self.orderSavingError = "User ID not found. Cannot save order."
            print("Order saving failed: User ID missing.")
            return
        }
        
        guard !fileUploaderViewModel.uploadedSupabasePaths.isEmpty else {
            self.orderSavingError = "No documents were uploaded. Cannot save order."
            print("Order saving failed: No documents uploaded.")
            return
        }

        self.isSavingOrder = true
        self.orderSavingError = nil
        self.successfullySavedOrderId = nil

        let pages = Int(numberOfPagesString) ?? 0
        let orderData = Order(
            user_id: currentUserId,
            user_email: self.userEmail,
            documents: self.fileUploaderViewModel.uploadedSupabasePaths.isEmpty ? nil : self.fileUploaderViewModel.uploadedSupabasePaths,
            language_from: self.languageFrom,
            language_to: self.languageTo,
            service_type: self.serviceType,
            page_count: serviceType == "Certified Translation" ? pages : nil,
            price_per_page: serviceType == "Certified Translation" ? pricePerPageCertified : nil,
            total_amount: self.calculatedPrice,
            stripe_payment_intent_id: paymentIntentId,
            order_status: status
        )

        do {
            // Define what data to get back. '.minimal' is also an option.
            // To get the 'id' back, we need to select it.
            let savedOrder: [OrderResponse] = try await SupabaseManager.shared.client.database
                .from("ios_orders")
                .insert(orderData, returning: .representation) // Request the inserted record back
                .select("id") // Specifically select the 'id' field
                .execute()
                .value
            
            if let firstOrder = savedOrder.first, let newOrderId = firstOrder.id {
                self.successfullySavedOrderId = newOrderId
                print("Order successfully saved to Supabase with ID: \(newOrderId)")
                // Clear form or reset relevant properties after successful save
                // self.fileUploaderViewModel.clearSelectedFiles() // Example
            } else {
                 print("Order saved but no ID returned or data was empty.")
                 self.orderSavingError = "Order saved, but failed to retrieve order ID."
            }
        } catch {
            print("Error saving order to Supabase: \(error)")
            self.orderSavingError = "Failed to save order: \(error.localizedDescription)"
        }
        self.isSavingOrder = false
    }

    // Placeholder for initial submit action before payment
    func prepareOrderForPayment() {
        guard !fileUploaderViewModel.uploadedSupabasePaths.isEmpty else {
            self.errorMessage = "Please upload at least one document."
            print("Order submission failed: No documents uploaded.")
            return
        }
        
        guard calculatedPrice > 0 else {
            self.errorMessage = "Calculated price is zero. Please check order details."
            print("Order submission failed: Price is zero.")
            return
        }
        self.errorMessage = nil
        print("Order details verified, proceeding to payment.")
    }
}

// Struct to decode the response when 'returning: .representation' is used
struct OrderResponse: Decodable {
    let id: UUID? // Make it optional as it might not always be there or needed
    // Add other fields if you select them
}
